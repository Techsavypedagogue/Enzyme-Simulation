<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Catalase Sim (Improved Fit Alert)</title> <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    /* --- Styles (Unchanged) --- */
    body { font-family: 'Inter', sans-serif; margin: 0; padding: 1rem; background: linear-gradient(to right, #fff7ed, #f0f9ff); color: #374151; line-height: 1.6; min-height: 100vh; }
    h2 { text-align: center; margin: 0.5rem 0 1rem 0; color: #1f2937; font-weight: 600; font-size: 1.25rem; }
    .top-container { display: flex; flex-wrap: wrap; gap: 1.5rem; max-width: 1600px; margin: 1rem auto; padding: 0 1rem; }
    .left-side { display: flex; flex-direction: column; gap: 1.5rem; flex: 1 1 800px; min-width: 300px; }
    .right-side { display: flex; flex-direction: column; flex: 1 1 700px; gap: 1.5rem; min-width: 300px; }
    .controls-box { background: #ffffff; border-radius: 0.75rem; padding: 1.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
    .mode-toggle { display: flex; justify-content: center; margin-bottom: 1rem; }
    .flex-row { display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center; align-items: stretch; margin: 1rem 0; }
    .input-box { display: flex; flex-direction: column; align-items: center; border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 0.75rem; background: #f9fafb; width: 130px; text-align: center; box-sizing: border-box; transition: border 0.3s, box-shadow 0.3s; }
    .input-label-container { display: flex; align-items: center; justify-content: center; gap: 0.3rem; margin-bottom: 0.25rem; min-height: 24px; height: 24px; line-height: 1; }
    .input-box label { font-weight: 600; color: #1f2937; margin: 0; font-size: 0.9rem; }
    .molecule-icon { display: inline-block; width: 12px; height: 12px; border-radius: 50%; vertical-align: middle; }
    .icon-enzyme { background-color: #fb923c; border: 1px solid #f97316; }
    .icon-substrate { width: 0; height: 0; border-left: 7px solid transparent; border-right: 7px solid transparent; border-bottom: 12px solid #60a5fa; background-color: transparent; border-radius: 0; filter: drop-shadow(0 1px 1px rgba(0,0,0,0.1)); }
    .icon-competitive { width: 0; height: 0; border-left: 7px solid transparent; border-right: 7px solid transparent; border-bottom: 12px solid #f87171; background-color: transparent; border-radius: 0; filter: drop-shadow(0 1px 1px rgba(0,0,0,0.1)); }
    .icon-noncompetitive { background-color: #9ca3af; border: 1px solid #4b5563; }
    .units { font-size: 0.8em; color: #6b7280; margin-bottom: 0.4rem; margin-top: 0.2rem; }
    .input-box input[type="range"] { width: 100px; margin: 0.4rem 0; cursor: pointer; accent-color: #f97316; }
    #enzymeVal, #substrateVal, #competitiveVal, #noncompetitiveVal, #tempVal, #phVal { font-weight: 600; color: #f97316; font-size: 0.9rem; }
    .buttons { display: flex; justify-content: center; gap: 1rem; margin-top: 1.5rem; flex-wrap: wrap; }
    button { padding: 0.75rem 1.5rem; font-size: 1rem; font-weight: 600; border: none; border-radius: 0.5rem; background-color: #f97316; color: #ffffff; cursor: pointer; transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
    button:hover:not(:disabled) { background-color: #ea580c; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
    button:disabled { opacity: 0.6; cursor: not-allowed; background-color: #fdba74; }
    #resetBtn { background-color: #60a5fa; } #resetBtn:hover:not(:disabled) { background-color: #3b82f6; } #resetBtn:disabled { opacity: 0.6; background-color: #60a5fa; }
    #csvBtn { background-color: #22c55e; } #csvBtn:hover:not(:disabled) { background-color: #16a34a; }
    #vmaxBtn { background-color: #ef4444; } #vmaxBtn:hover:not(:disabled) { background-color: #dc2626; }
    #variablesChosenBtn { background-color: #10b981; } #variablesChosenBtn:hover:not(:disabled) { background-color: #059669; }
    #addExperimentBtn { background-color: #f59e0b; } #addExperimentBtn:hover:not(:disabled) { background-color: #d97706; }
    .highlight-button-glow { box-shadow: 0 0 15px 5px #f97316; animation: pulse-glow 1.5s infinite alternate; }
    @keyframes pulse-glow { from { box-shadow: 0 0 8px 2px #fdba74; } to { box-shadow: 0 0 18px 6px #f97316; } }
    .highlight-input-glow { border: 2px solid #f97316 !important; box-shadow: 0 0 10px 2px #fdba74; }
    .animation-container { width: 100%; aspect-ratio: 800 / 500; height: auto; max-height: 500px; position: relative; background: #ffffff; border: 1px solid #e5e7eb; overflow: hidden; border-radius: 0.75rem; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
    .graph-container, .table-container, .vmax-graph-container, .vmax-experiments-container { background: #ffffff; border-radius: 0.75rem; padding: 1rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
    .table-container, .vmax-experiments-container { overflow-x: auto; }
    #graphCanvas { aspect-ratio: 650 / 300; max-height: 300px; }
    #vmaxGraphCanvas { aspect-ratio: 1 / 1; }
    #graphCanvas, #vmaxGraphCanvas { width: 100%; height: auto; background: #f9fafb; border: 1px solid #e5e7eb; display: block; border-radius: 0.5rem; }
    table { width: 100%; border-collapse: collapse; margin: 0.5rem 0; font-size: 0.9rem; }
    th, td { padding: 0.6rem 0.4rem; text-align: center; border: 1px solid #e5e7eb; }
    thead tr:first-child th { background: #e0f2fe; color: #0c4a6e; font-weight: 600; border-top-left-radius: 0.5rem; border-top-right-radius: 0.5rem; }
    thead tr:nth-child(2) th { background: #f0f9ff; color: #374151; font-weight: normal; }
    tbody tr:nth-child(even) { background-color: #f9fafb; }
    .vmax-experiments-container { display: none; }
    .vmax-experiments { display: flex; flex-wrap: nowrap; gap: 1rem; overflow-x: auto; padding-bottom: 1rem; }
    .vmax-experiment { margin-bottom: 0; width: 300px; flex-shrink: 0; }
    .vmax-experiment table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
    .vmax-experiment th, .vmax-experiment td { border: 1px solid #e5e7eb; padding: 0.5rem; text-align: center; }
    .vmax-experiment th { background: #e0f2fe; color: #0c4a6e; font-weight: 600; }
    .vmax-experiment .conditions { font-size: 0.85rem; text-align: left; padding: 0.5rem; background: #f9fafb; }
    .vmax-experiment .toggle-fit-btn {
        margin-left: 10px; padding: 2px 6px; font-size: 0.8em;
        border: 1px solid #d1d5db; border-radius: 4px;
        line-height: 1; vertical-align: middle;
        transition: background-color 0.2s, border-color 0.2s, color 0.2s, opacity 0.2s, box-shadow 0.3s;
        background-color: #f3f4f6;
        color: #9ca3af;
        opacity: 0.6;
        cursor: default;
        box-shadow: none;
        animation: none;
    }
    .vmax-experiment .toggle-fit-btn:not(:disabled) {
        cursor: pointer;
        opacity: 1.0;
    }
    .vmax-experiment .toggle-fit-btn.enabled {
        background-color: #60a5fa;
        border-color: #3b82f6;
        color: white;
        font-weight: normal;
    }
    .vmax-experiment .toggle-fit-btn.enabled:not(.active).highlight-button-glow {
        box-shadow: 0 0 15px 5px #f97316;
        animation: pulse-glow 1.5s infinite alternate;
    }
    .vmax-experiment .toggle-fit-btn.active {
        background-color: #f97316;
        border-color: #ea580c;
        color: white;
        font-weight: bold;
        box-shadow: none;
        animation: none;
    }
    .enzyme { position: absolute; width: 40px; height: 40px; background: radial-gradient(circle at 30% 30%, #fdba74, #fb923c 70%, #f97316 100%); border-radius: 50%; pointer-events: none; transition: background 0.2s, box-shadow 0.2s, border-radius 0.2s, transform 0.1s; z-index: 10; box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2), 0 2px 4px rgba(0,0,0,0.1); }
    .enzyme.fullyInhibited { background: radial-gradient(circle at 30% 30%, #a3a3a3, #737373 70%, #525252 100%); box-shadow: inset 2px 2px 5px rgba(0,0,0,0.3); }
    .enzyme.denatured {
        background: radial-gradient(ellipse at 60% 40%, #d1d5db, #9ca3af 70%, #6b7280 100%);
        border-radius: 45% 55% 60% 40% / 55% 45% 55% 45%;
        transform: rotate(25deg) scale(0.95);
        box-shadow: inset 1px 1px 4px rgba(0,0,0,0.4);
        opacity: 0.8;
    }
    .enzyme.blocked { box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2), 0 0 10px 5px rgba(239, 68, 68, 0.7); }
    .triangle { position: absolute; width: 0; height: 0; border-left: 9px solid transparent; border-right: 9px solid transparent; pointer-events: none; z-index: 5; filter: drop-shadow(1px 2px 2px rgba(0,0,0,0.3)); }
    .substrate { border-bottom: 16px solid #60a5fa; }
    .competitive { border-bottom: 16px solid #f87171; }
    .circle { position: absolute; width: 12px; height: 12px; background: radial-gradient(circle at 30% 30%, #e5e5e5, #a3a3a3 70%, #737373 100%); border-radius: 50%; pointer-events: none; z-index: 5; box-shadow: inset 1px 1px 3px rgba(0,0,0,0.3), 0 1px 2px rgba(0,0,0,0.1); }
    .product { position: absolute; width: 8px; height: 8px; background-color: #a0d2eb; border-radius: 50%; pointer-events: none; z-index: 1; box-shadow: inset 1px 1px 2px rgba(0,0,0,0.1), 0 1px 1px rgba(0,0,0,0.1); }
    .highlight-collision { transform: scale(1.1); box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2), 0 0 8px 4px rgba(239, 68, 68, 0.6); }
    #instructions { text-align: center; margin-bottom: 1rem; font-weight: 600; color: #1f2937; }
    .input-box.keyboard-active {
        border-color: #f97316;
        box-shadow: 0 0 5px 1px #fdba74;
    }
    @media (max-width: 1200px) { .left-side, .right-side { flex-basis: 100%; } .animation-container { max-height: 450px; } #graphCanvas { max-height: 280px; aspect-ratio: 600 / 300; } #vmaxGraphCanvas { max-height: 600px; aspect-ratio: 1 / 1; } }
    @media (max-width: 768px) { body { padding: 0.5rem; } .top-container { gap: 1rem; padding: 0 0.5rem; } .controls-box, .graph-container, .table-container, .vmax-graph-container, .vmax-experiments-container { padding: 1rem; } .input-box { width: 120px; padding: 0.6rem; } .input-box input[type="range"] { width: 90px; } .input-label-container { min-height: 20px; height: 20px; } .input-box label { font-size: 0.85rem; } button { padding: 0.6rem 1.2rem; font-size: 0.9rem; } h2 { font-size: 1.1rem; margin-bottom: 0.75rem; } table { font-size: 0.8rem; } th, td { padding: 0.5rem 0.3rem; } #graphCanvas { max-height: 240px; aspect-ratio: 500 / 300; } #vmaxGraphCanvas { max-height: 500px; aspect-ratio: 1 / 1; } .vmax-experiment { width: 250px; } }
    @media (max-width: 480px) { .input-box { width: 100px; padding: 0.5rem; } .input-box input[type="range"] { width: 70px; } .units { font-size: 0.75em; } .input-label-container { min-height: 18px; height: 18px; } .input-box label { font-size: 0.8rem; } button { padding: 0.5rem 1rem; font-size: 0.85rem; } #graphCanvas { max-height: 200px; aspect-ratio: 400 / 300; } #vmaxGraphCanvas { max-height: 400px; aspect-ratio: 1 / 1;} }
  </style>
</head>
<body>

    <div class="top-container">
      <div class="left-side">
        <div class="controls-box">
          <h2>Set Variables</h2>
          <div id="instructions"></div>
          <div class="mode-toggle"> <button id="vmaxBtn" onclick="toggleVmaxMode()">Toggle Vmax Mode</button> </div>
          <div class="flex-row">
            <div class="input-box"> <div class="input-label-container"> <span class="molecule-icon icon-enzyme"></span> <label>Catalase</label> </div> <div class="units">(mg/mL)</div> <input id="enzymeInput" type="range" min="0" max="100" step="5" value="50" oninput="sliderChange('enzyme','enzymeVal')"/> <span id="enzymeVal">50</span> </div>
            <div class="input-box">
                <div class="input-label-container"> <span class="molecule-icon icon-substrate"></span> <label>H₂O₂</label> </div>
                <div class="units">(mM)</div>
                <input id="substrateInput" type="range" min="0" max="800" step="20" value="100" oninput="sliderChange('substrate','substrateVal')"/>
                <span id="substrateVal">100</span>
            </div>
            <div class="input-box">
                <div class="input-label-container"> <span class="molecule-icon icon-competitive"></span> <label>Hydroxylamine sulfate</label> </div>
                <div class="units">(mM)</div>
                <input id="competitiveInput" type="range" min="0" max="50" step="1" value="0" oninput="sliderChange('competitive','competitiveVal')"/>
                <span id="competitiveVal">0</span>
            </div>
            <div class="input-box"> <div class="input-label-container"> <span class="molecule-icon icon-noncompetitive"></span> <label>Sodium Azide</label> </div> <div class="units">(mM)</div> <input id="noncompetitiveInput" type="range" min="0" max="10" step="0.5" value="0" oninput="sliderChange('noncompetitive','noncompetitiveVal')"/> <span id="noncompetitiveVal">0.0</span> </div>
            <div class="input-box"> <div class="input-label-container"> <label>Temperature</label> </div> <div class="units">(°C)</div> <input id="tempInput" type="range" min="0" max="60" step="1" value="37" oninput="sliderChange('temp','tempVal')"/> <span id="tempVal">37</span> </div>
            <div class="input-box"> <div class="input-label-container"> <label>pH</label> </div> <div class="units"></div> <input id="phInput" type="range" min="1" max="14" step="0.1" value="9" oninput="sliderChange('ph','phVal')"/> <span id="phVal">9.0</span> </div>
          </div>
          <div class="buttons">
            <button id="genBtn" onclick="generateResults()">Generate Results</button>
            <button id="resetBtn" onclick="resetExperiment()">Restart</button>
            <button id="csvBtn" onclick="exportToCSV()">Export CSV</button>
            <button id="variablesChosenBtn" onclick="setVariablesChosen()" style="display: none;">Variables Chosen</button>
            <button id="addExperimentBtn" onclick="addAnotherExperiment()" style="display: none;">Add Another Experiment</button>
          </div>
        </div>
        <div class="animation-container" id="animContainer"></div>

        <div style="margin-top: 1rem; padding-bottom: 1rem;">
          <img
            src="https://i.postimg.cc/dtTPJLz1/Start-and-end-screen-Tw-T-Banner.png"
            alt="TwT banner image"
            style="width: 100%; height: 260px; border: 1px solid #ccc; display: block; object-fit: cover; object-position: center; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);" /* Updated style */
          />
          <div style="font-size: 0.9em; color: #666; margin-top: 1rem; text-align: center;">
            © B. Moran 2025
          </div>
        </div>

      </div> <div class="right-side">
        <div class="graph-container"> <canvas id="graphCanvas"></canvas> </div>
        <div class="vmax-graph-container" style="display: none;"> <canvas id="vmaxGraphCanvas"></canvas> </div>
        <div class="table-container">
          <table>
            <thead>
              <tr>
                <th rowspan="2">Time (s)</th> <th colspan="5">O₂ (ppm)</th>
                <th rowspan="2">Mean</th> </tr>
              <tr>
                <th>Trial 1</th>
                <th>Trial 2</th>
                <th>Trial 3</th>
                <th>Trial 4</th>
                <th>Trial 5</th>
                </tr>
            </thead>
            <tbody id="resultsTable"></tbody>
          </table>
        </div>
        <div class="vmax-experiments-container"> <h2 id="vmaxTitle" style="text-align: center; width: 100%; margin-bottom: 0.5rem;">Vmax Calculations</h2> <div class="vmax-experiments"></div> </div>
      </div> </div> <script>
    // Script exactly as previous version (pH effects, Enter key, etc.)

    // --- PRNG ---
    let seed = 12345;
    function setSeed(newSeed) { seed = Math.floor(newSeed) % 2147483647; if (seed <= 0) seed += 2147483646; }
    function seededRandom() { seed = (seed * 16807) % 2147483647; return (seed - 1) / 2147483646; }

    // --- Global Variables ---
    const container = document.getElementById('animContainer');
    let containerW = container?.clientWidth || 800; let containerH = container?.clientHeight || 500;
    let molecules = []; let enzymes = []; let running = false; let animFrameId = null;
    let experimentInterval = null; let timeIndex = 0; let resultsData = [];
    let o2Cumulative = 0; let lastO2Value = 0; let experimentStartTime = 0; let totalProducts = 0;
    let slope = 0; let slopeLabelText = ""; const BLOCK_DURATION = 2000; const initialLagTime = 0.0;
    let reactionPossible = true; let finalO2Cumulative = -1;
    let theoreticalMaxO2 = 0; let theoreticalKappa = 0.01; let lastTheoreticalO2 = 0; lastO2Cumulative = 0;
    let isVmaxMode = false; let isSettingVariables = false;
    let currentExperiment = null;
    let experiments = [];
    let currentlyHoveredSlider = null;
    let isHoveringInputBox = false;

    // --- Global Constants ---
    const Km_equiv = 20;
    const Ki_comp_equiv = 30;
    const Ki_noncomp_equiv = 5;
    const Vmax_base_rate = 30.0;

    // --- Resize ---
    const resizeObserver = new ResizeObserver(entries => { for (let entry of entries) { if (entry.target === container) { containerW = container.clientWidth; containerH = container.clientHeight; updateCanvasSizes(); } } });
    if (container) resizeObserver.observe(container);
    function updateCanvasSizes() { const mainCanvas = document.getElementById('graphCanvas'); const vmaxCanvas = document.getElementById('vmaxGraphCanvas'); const graphContainer = mainCanvas.parentElement; const vmaxGraphContainer = vmaxCanvas.parentElement; if (graphContainer && graphContainer.offsetParent !== null && graphContainer.clientWidth > 0) { const containerWidth = graphContainer.clientWidth - 20; const aspectRatio = 650 / 300; const canvasWidth = Math.max(100, Math.floor(containerWidth)); const canvasHeight = Math.max(50, Math.floor(canvasWidth / aspectRatio)); if(mainCanvas.width !== canvasWidth || mainCanvas.height !== canvasHeight){ mainCanvas.width = canvasWidth; mainCanvas.height = canvasHeight; drawGraph(); } } if (vmaxGraphContainer && vmaxGraphContainer.offsetParent !== null && vmaxGraphContainer.clientWidth > 0) { const containerWidth = vmaxGraphContainer.clientWidth - 20; const aspectRatio = 1 / 1; const canvasWidth = Math.max(100, Math.floor(containerWidth)); const canvasHeight = Math.max(50, Math.floor(canvasWidth / aspectRatio)); if(vmaxCanvas.width !== canvasWidth || vmaxCanvas.height !== canvasHeight){ vmaxCanvas.width = canvasWidth; vmaxCanvas.height = canvasHeight; drawVmaxGraph(); } } }

    // --- Helpers & Factors ---
    function getRemainingSubstrateCount() { return molecules.filter(m => m.type === 'substrate' && m.el && m.el.parentNode).length; }
    function tempSpeedFactor(T) { const temp = Number(T); if (isNaN(temp) || temp <= 0) return 0.1; const referenceTemp = 37.0; const baseSpeedFactor = 3.0; return Math.max(0.1, (temp / referenceTemp) * baseSpeedFactor); }
    function enzymeActivityFactor(T) { const Tnum = Number(T); if (isNaN(Tnum)) return 0.1; const Tmin = 0; const Topt = 37; const Tmax = 50; const baseActivity = 0.1; if (Tnum <= Tmin) { return baseActivity; } else if (Tnum < Topt) { return baseActivity + (1.0 - baseActivity) * (Tnum - Tmin) / (Topt - Tmin); } else if (Tnum === Topt) { return 1.0; } else if (Tnum < Tmax) { return 1.0 * (Tmax - Tnum) / (Tmax - Topt); } else { return 0; } }
    function phFactor(pH) {
        const optimumPh = 9;
        const lowerBound = 5;
        const upperBound = 11;
        const gaussianRange = 2;
        if (pH < lowerBound || pH > upperBound) {
            return 0.0;
        } else {
            return Math.max(0, Math.exp(-((pH - optimumPh) ** 2) / (2 * (gaussianRange / 1.5) ** 2)));
        }
    }

    // --- Theoretical Calculations ---
    function calcRate(eVal, sValInput, cVal, ncVal, TVal, pHVal) {
        const activityF = enzymeActivityFactor(TVal);
        const phF = phFactor(pHVal);
        let effectiveE_relative = (eVal / 100) * activityF * phF;
        let Vmax_potential = Vmax_base_rate * effectiveE_relative;
        let Vmax_app = Vmax_potential / (1 + ncVal / Ki_noncomp_equiv);
        let Km_app = Km_equiv * (1 + cVal / Ki_comp_equiv);
        let denominator = Km_app + sValInput;
        if (denominator <= 0 || sValInput < 1e-9 || phF === 0) return 0;
        let initialRate = Vmax_app * sValInput / denominator;
        const finalRate = Math.max(0, initialRate);
        if (!isFinite(finalRate)) { console.error("calcRate non-finite!"); return 0; }
        return finalRate;
    }
    function calculateTheoreticalParams(eVal, sValInput, cVal, ncVal, TVal, pHVal) {
        let initialRate = calcRate(eVal, sValInput, cVal, ncVal, TVal, pHVal);
        theoreticalMaxO2 = Math.max(1.0, (initialRate > 0.1 ? (initialRate * 15 + sValInput * 0.5) : sValInput * 0.5));
        if (theoreticalMaxO2 > 0.1 && initialRate > 0) {
            theoreticalKappa = initialRate / theoreticalMaxO2;
        } else {
            theoreticalKappa = 0.01;
        }
        theoreticalKappa = Math.max(0.001, theoreticalKappa);
    }

    // --- UI Interaction ---
    function sliderChange(varName, spanId) { const input = document.getElementById(varName + 'Input'); const val = parseFloat(input.value); let displayVal = (varName === 'ph' || varName === 'noncompetitive') ? val.toFixed(1) : val.toString(); document.getElementById(spanId).textContent = displayVal; if (!running) setupScene(); }

    // --- Simulation Setup ---
    function setupScene() {
        if (container) { containerW = container.clientWidth; containerH = container.clientHeight; container.innerHTML = ""; }
        molecules = []; enzymes = []; slope = 0; slopeLabelText = "";
        const getSliderValue = (id) => parseFloat(document.getElementById(id)?.value || 0);
        let eVal, cVal, ncVal, TVal, pHVal, sValInput;
        if (isVmaxMode && !isSettingVariables && currentExperiment) {
            eVal = currentExperiment.variables.eVal; cVal = currentExperiment.variables.cVal; ncVal = currentExperiment.variables.ncVal; TVal = currentExperiment.variables.TVal; pHVal = currentExperiment.variables.pHVal; sValInput = getSliderValue('substrateInput');
        } else {
            eVal = getSliderValue('enzymeInput'); sValInput = getSliderValue('substrateInput'); cVal = getSliderValue('competitiveInput'); ncVal = getSliderValue('noncompetitiveInput'); TVal = getSliderValue('tempInput'); pHVal = getSliderValue('phInput');
        }
        calculateTheoreticalParams(eVal, sValInput, cVal, ncVal, TVal, pHVal);

        let eCount = eVal > 0 ? Math.min(60, Math.max(1, Math.floor(eVal / 1.8))) : 0;
        let subCount = sValInput > 0 ? Math.min(400, Math.max(5, Math.floor(sValInput * 1.0))) : 0;
        let compCount = Math.min(60, Math.max(0, Math.floor(cVal * 6)));
        let ncCount = Math.min(120, Math.max(0, Math.floor(ncVal * 12)));

        let tempActivityFactor = enzymeActivityFactor(TVal);
        const optimumPh = 9;
        const lowerPhLimit = 5;
        const upperPhLimit = 11;

        for (let i = 0; i < eCount; i++) {
            let enz = createEnzymeObj();
            let denaturedByTemp = (TVal > 37 && seededRandom() < (1 - tempActivityFactor));
            let denaturedByPh = false;
            if (pHVal < lowerPhLimit || pHVal > upperPhLimit) {
                denaturedByPh = true;
            } else if (pHVal !== optimumPh) {
                let distanceFromOpt = Math.abs(pHVal - optimumPh);
                let maxDistance = Math.max(optimumPh - lowerPhLimit, upperPhLimit - optimumPh);
                if (maxDistance > 0) {
                    let denaturationFractionPh = Math.min(1, distanceFromOpt / maxDistance);
                    if (seededRandom() < denaturationFractionPh) {
                        denaturedByPh = true;
                    }
                }
            }
            if (denaturedByTemp || denaturedByPh) {
                enz.denatured = true;
                enz.el.classList.add('denatured');
            }
            if (container) container.appendChild(enz.el);
            enzymes.push(enz);
        }
        for (let i = 0; i < subCount; i++) { let sb = createMolObj('substrate'); if (container) container.appendChild(sb.el); molecules.push(sb); }
        for (let i = 0; i < compCount; i++) { let co = createMolObj('competitive'); if (container) container.appendChild(co.el); molecules.push(co); }
        for (let i = 0; i < ncCount; i++) { let nco = createMolObj('noncompetitive'); if (container) container.appendChild(nco.el); molecules.push(nco); }
        drawGraph();
    }
    function createEnzymeObj() { let el = document.createElement('div'); el.className = 'enzyme'; let size = 40; let x = seededRandom() * (containerW - size); let y = seededRandom() * (containerH - size); el.style.left = x + 'px'; el.style.top = y + 'px'; return { el, x, y, vx: 0, vy: 0, blockedUntil: 0, fullyInhibited: false, denatured: false, size }; }
    function createMolObj(type) { let el = document.createElement('div'); let w = 0, h = 0, size = 0; if (type === 'substrate') { el.className = 'triangle substrate'; w = 18; h = 16; size = 16; } else if (type === 'competitive') { el.className = 'triangle competitive'; w = 18; h = 16; size = 16; } else if (type === 'noncompetitive') { el.className = 'circle'; w = 12; h = 12; size = 12; } else if (type === 'product') { el.className = 'product'; w = 8; h = 8; size = 8; } let x = seededRandom() * (containerW - w); let y = seededRandom() * (containerH - h); el.style.left = x + 'px'; el.style.top = y + 'px'; return { type, el, x, y, vx: 0, vy: 0, w, h, size }; }

    // --- Simulation Control ---
    function generateResults() {
        if (running) { alert("Simulation already running!"); return; }
        running = true;
        lockControls(true);
        resultsData = [];
        document.getElementById('resultsTable').innerHTML = "";
        timeIndex = 0; o2Cumulative = 0; lastO2Value = 0; slope = 0; slopeLabelText = "";
        totalProducts = 0; finalO2Cumulative = -1; lastTheoreticalO2 = 0; lastO2Cumulative = 0;

        const getSliderValue = (id) => parseFloat(document.getElementById(id)?.value || 0);
        let eVal, sValInput, cVal, ncVal, TVal, pHVal;
        if (isVmaxMode && !isSettingVariables && currentExperiment) {
            eVal = currentExperiment.variables.eVal; cVal = currentExperiment.variables.cVal;
            ncVal = currentExperiment.variables.ncVal; TVal = currentExperiment.variables.TVal;
            pHVal = currentExperiment.variables.pHVal; sValInput = getSliderValue('substrateInput');
        } else {
            eVal = getSliderValue('enzymeInput'); sValInput = getSliderValue('substrateInput');
            cVal = getSliderValue('competitiveInput'); ncVal = getSliderValue('noncompetitiveInput');
            TVal = getSliderValue('tempInput'); pHVal = getSliderValue('phInput');
        }

        let newSeed = eVal * 100000 + sValInput * 1000 + ncVal * 100 + cVal * 10 + TVal * 10000 + pHVal * 1000000 + Date.now();
        setSeed(newSeed);

        calculateTheoreticalParams(eVal, sValInput, cVal, ncVal, TVal, pHVal);
        setupScene();
        experimentStartTime = Date.now();
        let activeEnzymes = enzymes.filter(e => !e.denatured && !e.fullyInhibited);
        let initialSubstrateCount = molecules.filter(m => m.type === 'substrate').length;
        reactionPossible = (activeEnzymes.length > 0 && initialSubstrateCount > 0 && calcRate(eVal, sValInput, cVal, ncVal, TVal, pHVal) > 1e-9);

        if (isVmaxMode && !isSettingVariables && sValInput < 1e-9) {
            if (!currentExperiment.data.some(d => d.h2o2 < 1e-9)) {
                console.log("Zero substrate detected in Vmax mode. Recording rate 0 immediately.");
                currentExperiment.data.push({ h2o2: 0, rate: 0 });
                renderVmaxExperiments();
                drawVmaxGraph();
            }
            slopeLabelText = "Initial rate: 0.000 ppm/s (No Substrate)";
            reactionPossible = false;
        }

        if (!reactionPossible) {
            if (!slopeLabelText) {
                 if (phFactor(pHVal) === 0.0) {
                     slopeLabelText = "Initial rate: 0.0 ppm/s (pH out of range)";
                 } else {
                     slopeLabelText = "Initial rate: 0.0 ppm/s (No Reaction)";
                 }
            }
            console.warn("Reaction not possible...");
        } else {
             if (!slopeLabelText) {
                 slopeLabelText = isVmaxMode ? "Initial rate: Calculating..." : "";
             }
        }

        let speed = tempSpeedFactor(TVal);
        for (let e of enzymes) { let enzymeSpeedMultiplier = e.denatured ? 0.2 : 1.0; e.vx = (seededRandom() - 0.5) * 0.4 * speed * enzymeSpeedMultiplier; e.vy = (seededRandom() - 0.5) * 0.4 * speed * enzymeSpeedMultiplier; }
        for (let m of molecules) { if (m.type === 'product') continue; let baseSpeed = 1.0 * speed + (seededRandom() * 0.5 * speed); m.vx = (seededRandom() - 0.5) * baseSpeed; m.vy = (seededRandom() - 0.5) * baseSpeed; }

        startAnimationLoop();
        addTimeRow(0);
        experimentInterval = setInterval(() => {
            timeIndex++;
            let simTime = timeIndex * 0.5;
            addTimeRow(simTime);
            if (timeIndex >= 60) stopSimulation();
        }, 83);
    }

    function lockControls(disable) { if (!isVmaxMode || (isVmaxMode && isSettingVariables)) { ['enzyme', 'substrate', 'competitive', 'noncompetitive', 'temp', 'ph'].forEach(id => { const input = document.getElementById(id + 'Input'); if(input) input.disabled = disable; }); } else if (isVmaxMode && !isSettingVariables) { ['enzyme', 'competitive', 'noncompetitive', 'temp', 'ph'].forEach(id => { const input = document.getElementById(id + 'Input'); if(input) input.disabled = true; }); const subInput = document.getElementById('substrateInput'); if(subInput) subInput.disabled = disable; } document.getElementById('genBtn').disabled = disable; document.getElementById('csvBtn').disabled = disable; document.getElementById('variablesChosenBtn').disabled = disable; document.getElementById('addExperimentBtn').disabled = disable; }
    function startAnimationLoop() { if (animFrameId) cancelAnimationFrame(animFrameId); function loop() { if (!running) return; tick(); animFrameId = requestAnimationFrame(loop); } animFrameId = requestAnimationFrame(loop); }
    function stopAnimationLoop() { if (animFrameId) cancelAnimationFrame(animFrameId); animFrameId = null; }
    function tick() { let now = Date.now(); let currentSimulatedTime = experimentStartTime ? (now - experimentStartTime) / 500.0 : 0; let activeEnzymesThisTick = []; for (let e of enzymes) { if (e.blockedUntil > 0 && now > e.blockedUntil) { e.blockedUntil = 0; e.el.classList.remove('blocked'); } let speedMultiplier = e.denatured ? 0.2 : e.fullyInhibited ? 0.5 : e.blockedUntil > 0 ? 0.7 : 1.0; e.x += e.vx * speedMultiplier; e.y += e.vy * speedMultiplier; if (e.x < 0) { e.x = 0; e.vx *= -1; } if (e.x > containerW - e.size) { e.x = containerW - e.size; e.vx *= -1; } if (e.y < 0) { e.y = 0; e.vy *= -1; } if (e.y > containerH - e.size) { e.y = containerH - e.size; e.vy *= -1; } e.el.style.left = e.x + 'px'; e.el.style.top = e.y + 'px'; if (!e.denatured && !e.fullyInhibited && e.blockedUntil === 0) { activeEnzymesThisTick.push(e); } } for (let i = molecules.length - 1; i >= 0; i--) { let m = molecules[i]; if (!m || !m.el) continue; let speedMultiplier = (m.type === 'product') ? 0.5 : 1.0; m.x += m.vx * speedMultiplier; m.y += m.vy * speedMultiplier; if (m.x < 0) { m.x = 0; m.vx *= -1; } if (m.x > containerW - m.w) { m.x = containerW - m.w; m.vx *= -1; } if (m.y < 0) { m.y = 0; m.vy *= -1; } if (m.y > containerH - m.h) { m.y = containerH - m.h; m.vy *= -1; } m.el.style.left = m.x + 'px'; m.el.style.top = m.y + 'px'; if (m.type !== 'product' && reactionPossible && activeEnzymesThisTick.length > 0) { for (let eObj of activeEnzymesThisTick) { if (m.x < eObj.x + eObj.size && m.x + m.w > eObj.x && m.y < eObj.y + eObj.size && m.y + m.h > eObj.y) { let dx = (m.x + m.w / 2) - (eObj.x + eObj.size / 2); let dy = (m.y + m.h / 2) - (eObj.y + eObj.size / 2); let dist = Math.sqrt(dx * dx + dy * dy); let collisionThreshold = (eObj.size / 2) + (m.size / 2) - 2; if (dist < collisionThreshold) { handleCollision(m, i, eObj, now, currentSimulatedTime); if (!molecules[i] || molecules[i] !== m) break; } } } } } }
    function handleCollision(m, moleculeIndex, eObj, now, currentSimulatedTime) { highlight(eObj); if (eObj.denatured || eObj.fullyInhibited || eObj.blockedUntil > now) return; if (m.type === 'noncompetitive') { eObj.fullyInhibited = true; eObj.el.classList.add('fullyInhibited'); if (m.el && m.el.parentNode) m.el.parentNode.removeChild(m.el); molecules.splice(moleculeIndex, 1); } else if (m.type === 'competitive') { eObj.blockedUntil = now + BLOCK_DURATION; eObj.el.classList.add('blocked'); m.vx *= -1; m.vy *= -1; } else if (m.type === 'substrate') { const pHVal = parseFloat(document.getElementById('phInput')?.value || 9); const currentPhFactor = phFactor(pHVal); if (seededRandom() < currentPhFactor) { o2Cumulative++; produceProducts(m.x + m.w / 2, m.y + m.h / 2); if (m.el && m.el.parentNode) m.el.parentNode.removeChild(m.el); molecules.splice(moleculeIndex, 1); } else { m.vx *= -1; m.vy *= -1; } } }
    function produceProducts(x, y) { totalProducts++; let p = createMolObj('product'); p.x = x - p.w / 2; p.y = y - p.h / 2; p.vx = (seededRandom() - 0.5) * 0.5; p.vy = (seededRandom() - 0.5) * 0.5; if (container) container.appendChild(p.el); molecules.push(p); }
    function highlight(eObj) { eObj.el.classList.add('highlight-collision'); setTimeout(() => { if(eObj && eObj.el) eObj.el.classList.remove('highlight-collision'); }, 150); }
    function addTimeRow(timeS) { let rawTrials = [0, 0, 0, 0, 0]; let finalMean = 0; let perfectReading = 0; let currentTheoreticalO2 = 0; const regressionTimeLimit = 1.0; if (timeS > 0 && theoreticalMaxO2 > 0 && theoreticalKappa > 0) { currentTheoreticalO2 = theoreticalMaxO2 * (1 - Math.exp(-theoreticalKappa * timeS)); currentTheoreticalO2 = Math.max(0, currentTheoreticalO2); } if (timeS === 0) { finalMean = 0; lastO2Value = 0; finalO2Cumulative = -1; lastTheoreticalO2 = 0; lastO2Cumulative = 0; rawTrials.fill(0); } else if (!reactionPossible) { finalMean = 0; lastO2Value = 0; finalO2Cumulative = 0; perfectReading = 0; rawTrials.fill(0); } else if (timeS <= regressionTimeLimit) { let theoreticalO2 = theoreticalMaxO2 * (1 - Math.exp(-theoreticalKappa * timeS)); let smallNoise = (seededRandom() - 0.5) * 0.5; finalMean = Math.max(0, theoreticalO2 + smallNoise); rawTrials = rawTrials.map(() => finalMean + (seededRandom() - 0.5) * 0.1); } else { if (finalO2Cumulative >= 0) { perfectReading = finalO2Cumulative; } else if (currentTheoreticalO2 >= theoreticalMaxO2 * 0.995 && timeIndex > 1) { finalO2Cumulative = theoreticalMaxO2; perfectReading = finalO2Cumulative; } else { perfectReading = currentTheoreticalO2; } let noiseAmplitude = perfectReading * 0.05 + 1; let deviationFactor = 0; let deltaCollisions = o2Cumulative - lastO2Cumulative; let deltaTheoretical = currentTheoreticalO2 - lastTheoreticalO2; if (deltaTheoretical > 0.1) { deviationFactor = (deltaCollisions / deltaTheoretical) - 1; } else if (deltaCollisions > 0) { deviationFactor = 0.5; } deviationFactor = Math.max(-0.8, Math.min(0.8, deviationFactor)); let sum = 0; for (let i = 0; i < 5; i++) { let deviationOffset = deviationFactor * noiseAmplitude * 0.6; let randomOffset = (seededRandom() - 0.5) * 2 * noiseAmplitude * 0.4; let val = Math.max(0, perfectReading + deviationOffset + randomOffset); if (finalO2Cumulative >= 0) { val = Math.max(0, finalO2Cumulative + deviationOffset + randomOffset); } rawTrials[i] = val; sum += val; } finalMean = sum / rawTrials.length; finalMean = Math.max(0, finalMean); } lastTheoreticalO2 = currentTheoreticalO2; lastO2Cumulative = o2Cumulative; lastO2Value = finalMean; resultsData.push({ time: timeS, trials: rawTrials, mean: finalMean }); let tb = document.getElementById('resultsTable'); if (tb) { let tr = document.createElement('tr'); tr.innerHTML = `<td>${timeS.toFixed(1)}</td>` + rawTrials.map(v => `<td>${v.toFixed(2)}</td>`).join('') + `<td>${finalMean.toFixed(2)}</td>`; tb.appendChild(tr); } drawGraph(); }

    function stopSimulation(immediate = false) {
        if (!running && !immediate) return;
        stopAnimationLoop();
        if (experimentInterval) clearInterval(experimentInterval);
        experimentInterval = null;

        if (running || immediate) {
            running = false;
            lockControls(false);

            if (!immediate && (reactionPossible || (isVmaxMode && !isSettingVariables && currentExperiment))) {
                computeInitialSlope();

                if (isVmaxMode && !isSettingVariables && currentExperiment) {
                    const h2o2 = parseFloat(document.getElementById('substrateVal').textContent);
                    const rateForTable = slope;
                    let finalRate = isFinite(rateForTable) ? Math.max(0, rateForTable) : 0;

                    console.log(`Storing Vmax point: H2O2=${h2o2.toFixed(1)}, Rate(from graph slope)=${finalRate.toFixed(3)}`);

                    if (h2o2 >= 1e-9) {
                        if (!currentExperiment.data.some(d => Math.abs(d.h2o2 - h2o2) < 1e-9)) {
                            currentExperiment.data.push({ h2o2, rate: finalRate });
                        }
                    } else {
                        if (!currentExperiment.data.some(d => d.h2o2 < 1e-9)) {
                            currentExperiment.data.push({ h2o2: 0, rate: 0 });
                            console.warn("StopSim: Added missing zero-rate point as fallback.");
                        }
                    }
                    renderVmaxExperiments();
                    drawVmaxGraph();
                }
            } else if (!immediate) {
                slope = 0;
                if (!slopeLabelText) {
                     const pHVal = parseFloat(document.getElementById('phInput')?.value || 9);
                     if (phFactor(pHVal) === 0.0) {
                         slopeLabelText = "Initial rate: 0.0 ppm/s (pH out of range)";
                     } else if (!reactionPossible) {
                         slopeLabelText = "Initial rate: 0.0 ppm/s (No Reaction)";
                     } else if (resultsData.length <= 2) {
                         slopeLabelText = "Initial rate: Too short";
                     } else {
                         slopeLabelText = "Initial rate: ~0.0 ppm/s";
                     }
                }
            }
            if (!immediate) drawGraph();
        }
    }

    function resetExperiment() { stopSimulation(true); resultsData = []; o2Cumulative = 0; lastO2Value = 0; slope = 0; reactionPossible = true; finalO2Cumulative = -1; totalProducts = 0; slopeLabelText = ""; lastTheoreticalO2 = 0; lastO2Cumulative = 0; theoreticalMaxO2 = 0; theoreticalKappa = 0.01; document.getElementById('resultsTable').innerHTML = ""; if (container) container.innerHTML = ""; enzymes = []; molecules = []; if (isVmaxMode) { experiments = []; currentExperiment = { variables: {}, data: [], fittedParams: null, showFit: false }; isSettingVariables = true; document.querySelector('.vmax-experiments').innerHTML = ''; drawVmaxGraph(); } else { currentExperiment = null; isSettingVariables = false; } setupScene(); updateUI(); drawGraph(); updateCanvasSizes(); }
    function exportToCSV() { const now = new Date(); const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`; let csv = ""; let filename = ""; if (isVmaxMode) { let allExperimentsData = [...experiments]; if (currentExperiment && currentExperiment.data && currentExperiment.data.length > 0) { allExperimentsData.push(currentExperiment); } if (allExperimentsData.length === 0) { alert("No Vmax experiment data to export."); return; } filename = `catalase_vmax_data_${timestamp}.csv`; allExperimentsData.forEach((exp, idx) => { csv += `Experiment ${idx + 1}\n`;
    csv += `Conditions:,Catalase (mg/ml),${exp.variables.eVal},Hydroxylamine sulfate (mM),${exp.variables.cVal},Sodium Azide (mM),${exp.variables.ncVal},Temp (C),${exp.variables.TVal},pH,${exp.variables.pHVal}\n`; csv += "H2O2_Concentration(mM),Mean_Initial_Rate(ppm/s)\n"; const sortedData = [...exp.data].sort((a, b) => a.h2o2 - b.h2o2); sortedData.forEach(d => { csv += `${d.h2o2.toFixed(1)},${d.rate.toFixed(3)}\n`; }); csv += "\n"; }); } else { if (resultsData.length === 0) { alert("No raw data to export."); return; } filename = `catalase_kinetics_${timestamp}.csv`; csv = "Time(s),Trial1(ppm),Trial2(ppm),Trial3(ppm),Trial4(ppm),Trial5(ppm),Mean(ppm)\n"; for (let r of resultsData) { let arr = [r.time.toFixed(1), ...r.trials.map(t => t.toFixed(2)), r.mean.toFixed(2)]; csv += arr.join(",") + "\n"; } } const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.setAttribute("download", filename); document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); }
    function computeInitialSlope() { slope = 0; slopeLabelText = "Initial rate: Calculating..."; const regressionTimeLimit = 1.0; let pointsForRegression = resultsData.filter(p => p.time > 0 && p.time <= regressionTimeLimit && p.mean >= 0); pointsForRegression.unshift({ time: 0, mean: 0 }); let n = pointsForRegression.length; if (n >= 2) { let sum_x = 0, sum_y = 0, sum_xy = 0, sum_x_squared = 0; for (let point of pointsForRegression) { sum_x += point.time; sum_y += point.mean; sum_xy += point.time * point.mean; sum_x_squared += point.time * point.time; } let denominator = (n * sum_x_squared - sum_x * sum_x); if (Math.abs(denominator) > 1e-9) { slope = (n * sum_xy - sum_x * sum_y) / denominator; slope = Math.max(0, slope); slopeLabelText = `Initial rate: ${slope.toFixed(3)} ppm/s`; } else { slope = 0; slopeLabelText = "Initial rate: ~0.0 ppm/s (Flat)"; } } else { slope = 0; slopeLabelText = "Initial rate: Too few points"; } }
    function toggleVmaxMode() { isVmaxMode = !isVmaxMode; document.getElementById('vmaxBtn').textContent = isVmaxMode ? "Exit Vmax Mode" : "Toggle Vmax Mode"; resetExperiment(); }
    function setVariablesChosen() { const getSliderValue = (id) => parseFloat(document.getElementById(id).value); currentExperiment.variables = { eVal: getSliderValue('enzymeInput'), cVal: getSliderValue('competitiveInput'), ncVal: getSliderValue('noncompetitiveInput'), TVal: getSliderValue('tempInput'), pHVal: getSliderValue('phInput') }; currentExperiment.fittedParams = null; currentExperiment.showFit = false; isSettingVariables = false; updateUI(); }
    function addAnotherExperiment() { if (currentExperiment && currentExperiment.data && currentExperiment.data.length > 0) { experiments.push(currentExperiment); } currentExperiment = { variables: {}, data: [], fittedParams: null, showFit: false }; isSettingVariables = true; renderVmaxExperiments(); updateUI(); drawVmaxGraph(); }
    function calculateFit(dataPoints) { if (!dataPoints || dataPoints.length < 2) return null; let validData = dataPoints.filter(d => d.h2o2 > 1e-6 && d.rate > 1e-6); if (validData.length < 2) return null; let x = validData.map(d => 1 / d.h2o2); let y = validData.map(d => 1 / d.rate); let n = x.length; let sum_x = x.reduce((a, b) => a + b, 0); let sum_y = y.reduce((a, b) => a + b, 0); let sum_xy = x.reduce((a, b, i) => a + b * y[i], 0); let sum_xx = x.reduce((a, b) => a + b * b, 0); let denominator = (n * sum_xx - sum_x * sum_x); if (Math.abs(denominator) < 1e-9) return null; let slopeLB = (n * sum_xy - sum_x * sum_y) / denominator; let intercept = (sum_y - slopeLB * sum_x) / n; if (intercept <= 1e-9 || slopeLB < 0) return null; let Vmax = 1 / intercept; let Km = slopeLB * Vmax; return { Vmax, Km }; }

    // *** MODIFIED toggleFitLine ***
    function toggleFitLine(index) {
        let targetExperiment = null;
        if (index < experiments.length) {
            targetExperiment = experiments[index];
        } else if (index === experiments.length && currentExperiment) {
            targetExperiment = currentExperiment;
        }
        if (!targetExperiment) return;

        targetExperiment.showFit = !targetExperiment.showFit;

        if (targetExperiment.showFit && !targetExperiment.fittedParams) {
            if (targetExperiment.data && targetExperiment.data.length >= 5) {
                targetExperiment.fittedParams = calculateFit(targetExperiment.data);
                if (!targetExperiment.fittedParams) {
                    // *** UPDATED Alert Message ***
                    alert(`Could not calculate fit for Experiment ${index + 1}. This usually happens when the measured initial rates for the data points are too close to zero (Rate ≤ 0.000001 ppm/s) due to the experimental conditions (e.g., extreme pH or temperature, high inhibitor concentration). The fitting calculation requires at least two data points with rates significantly above zero.`);
                    targetExperiment.showFit = false; // Turn fit back off
                }
            } else {
                 // Keep original alert for insufficient *total* points
                alert(`Cannot plot fit for Experiment ${index + 1}. Need at least 5 data points.`);
                targetExperiment.showFit = false;
            }
        }
        renderVmaxExperiments();
        drawVmaxGraph();
    }
    // *** END MODIFIED toggleFitLine ***

    function renderVmaxExperiments() { const container = document.querySelector('.vmax-experiments'); container.innerHTML = ''; let allExperimentsToDisplay = [...experiments]; if (currentExperiment && currentExperiment.variables && Object.keys(currentExperiment.variables).length > 0) { allExperimentsToDisplay.push(currentExperiment); } allExperimentsToDisplay.forEach((exp, idx) => { let expDiv = document.createElement('div'); expDiv.className = 'vmax-experiment'; let table = document.createElement('table'); let header = document.createElement('tr'); let isEnabled = exp.data && exp.data.length >= 5; let btnClass = 'toggle-fit-btn'; let btnDisabled = !isEnabled ? ' disabled' : ''; if (isEnabled) { btnClass += ' enabled'; if (exp.showFit) { btnClass += ' active'; } else { btnClass += ' highlight-button-glow'; } } let toggleBtnHTML = `<button class="${btnClass}" onclick="toggleFitLine(${idx})" title="Toggle Trend Line"${btnDisabled}>Fit</button>`; header.innerHTML = `<th colspan="2">Experiment ${idx + 1} ${toggleBtnHTML}</th>`; table.appendChild(header); let conditions = document.createElement('tr');
    conditions.innerHTML = `<td colspan="2" class="conditions">` + `Cat: ${exp.variables.eVal || '-'} mg/ml, ` + `Hydroxylamine sulfate: ${exp.variables.cVal || 0} mM, ` + `NaN₃: ${exp.variables.ncVal || 0} mM, ` + `T: ${exp.variables.TVal || '-'} °C, ` + `pH: ${exp.variables.pHVal ? exp.variables.pHVal.toFixed(1) : '-'}</td>`; table.appendChild(conditions); let dataHeader = document.createElement('tr'); dataHeader.innerHTML = `<th>H₂O₂ (mM)</th><th>Rate (ppm/s)</th>`; table.appendChild(dataHeader); if(exp.data){ const sortedData = [...exp.data].sort((a, b) => a.h2o2 - b.h2o2); sortedData.forEach(d => { let row = document.createElement('tr'); row.innerHTML = `<td>${d.h2o2.toFixed(1)}</td><td>${d.rate.toFixed(3)}</td>`; table.appendChild(row); }); } expDiv.appendChild(table); container.appendChild(expDiv); }); }

    function drawGraph() {
        const canvas = document.getElementById('graphCanvas');
        if (!canvas || !canvas.getContext) return;
        const ctx = canvas.getContext('2d');
        const padding = 40;
        const graphWidth = canvas.width - 2 * padding;
        const graphHeight = canvas.height - 2 * padding;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#f9fafb";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const maxTime = 30;
        let maxMean = 1;
        if (Array.isArray(resultsData) && resultsData.length > 0) {
            maxMean = Math.max(1, ...resultsData.map(r => r.mean)) * 1.1;
        } else if (theoreticalMaxO2 > 0) {
             maxMean = Math.max(1, theoreticalMaxO2) * 1.1;
        }
        // Y Axis Ticks and Labels
        ctx.strokeStyle = "#d1d5db"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(padding, padding); ctx.lineTo(padding, canvas.height - padding); ctx.stroke();
        ctx.textAlign = "right"; ctx.textBaseline = "middle";
        const numYTicks = 5;
        for (let i = 0; i <= numYTicks; i++) {
            let yVal = (maxMean / numYTicks) * i;
            let y = (canvas.height - padding) - (yVal / maxMean) * graphHeight;
            ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(padding - 5, y); ctx.stroke();
            let yLabel = yVal < 1 ? yVal.toFixed(1) : Math.round(yVal).toString();
            ctx.fillStyle = "#6b7280"; ctx.font = "11px 'Inter', sans-serif"; ctx.fillText(yLabel, padding - 8, y);
        }
        // Y Axis Title (Position Adjusted)
        ctx.save();
        ctx.translate(5, canvas.height / 2); // Adjusted X position
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = "center";
        ctx.fillStyle = "#374151";
        ctx.font = "bold 12px 'Inter', sans-serif";
        ctx.fillText("Mean O₂ (ppm)", 0, 0);
        ctx.restore();
        // X Axis
        ctx.beginPath(); ctx.moveTo(padding, canvas.height - padding); ctx.lineTo(canvas.width - padding, canvas.height - padding); ctx.stroke();
        ctx.textAlign = "center"; ctx.textBaseline = "top";
        for (let t = 0; t <= maxTime; t += 5) {
            let x = padding + (t / maxTime) * graphWidth;
            ctx.beginPath(); ctx.moveTo(x, canvas.height - padding); ctx.lineTo(x, canvas.height - padding + 5); ctx.stroke();
            ctx.fillStyle = "#6b7280"; ctx.font = "11px 'Inter', sans-serif"; ctx.fillText(t.toString(), x, canvas.height - padding + 8);
        }
        ctx.fillStyle = "#374151"; ctx.font = "bold 12px 'Inter', sans-serif";
        ctx.fillText("Time (s)", canvas.width / 2, canvas.height - padding + 25);
        // Plot Data Points
        if (Array.isArray(resultsData) && resultsData.length > 0) {
            ctx.strokeStyle = "#3b82f6"; ctx.lineWidth = 2; ctx.lineJoin = "round"; ctx.lineCap = "round";
            ctx.beginPath();
            let firstPoint = true;
            resultsData.forEach((r) => {
                if (r && typeof r.mean === 'number' && typeof r.time === 'number') {
                    let x = padding + (r.time / maxTime) * graphWidth;
                    let clampedMean = Math.max(0, Math.min(r.mean, maxMean));
                    let y = (canvas.height - padding) - (clampedMean / maxMean) * graphHeight;
                    if (isFinite(x) && isFinite(y)) {
                        if (firstPoint) { ctx.moveTo(x, y); firstPoint = false; }
                        else { ctx.lineTo(x, y); }
                    }
                }
            });
            if (!firstPoint) ctx.stroke();
            ctx.fillStyle = "#f97316";
            resultsData.forEach(r => {
                if (r && typeof r.mean === 'number' && typeof r.time === 'number') {
                    let x = padding + (r.time / maxTime) * graphWidth;
                    let clampedMean = Math.max(0, Math.min(r.mean, maxMean));
                    let y = (canvas.height - padding) - (clampedMean / maxMean) * graphHeight;
                    if (isFinite(x) && isFinite(y)) {
                        ctx.beginPath(); ctx.arc(x, y, 3, 0, 2 * Math.PI); ctx.fill();
                    }
                }
            });
        }
        // Draw Initial Slope Line and Label (longer, dashed)
        if (slopeLabelText && !running) {
             if (slope > 1e-6) {
                ctx.strokeStyle = "#ef4444";
                ctx.lineWidth = 3.0;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                let startTime = 0; let startMean = 0;
                let startX = padding + (startTime / maxTime) * graphWidth;
                let startY = (canvas.height - padding) - (startMean / maxMean) * graphHeight;
                let tangentDuration = 10.0;
                let endTime = startTime + tangentDuration;
                let yValAtEnd = startMean + slope * tangentDuration;
                let endX = padding + (endTime / maxTime) * graphWidth;
                let clampedYVal = Math.max(0, Math.min(yValAtEnd, maxMean));
                let endY = (canvas.height - padding) - (clampedYVal / maxMean) * graphHeight;
                if (yValAtEnd >= maxMean && slope > 1e-9) {
                   let timeToMax = (maxMean - startMean) / slope;
                   endTime = startTime + timeToMax;
                   endX = padding + (endTime / maxTime) * graphWidth;
                   endY = padding;
                }
                endX = Math.min(endX, padding + graphWidth);
                endX = Math.min(endX, canvas.width - padding);
                if (isFinite(startX) && isFinite(startY) && isFinite(endX) && isFinite(endY) && (Math.abs(endX - startX) > 1 || Math.abs(endY - startY) > 1)) {
                    ctx.moveTo(startX, startY); ctx.lineTo(endX, endY); ctx.stroke();
                }
                ctx.setLineDash([]);
            }
            ctx.fillStyle = "#ef4444";
            ctx.font = "bold 12px 'Inter', sans-serif";
            ctx.textAlign = "left";
            ctx.textBaseline = "top";
            ctx.fillText(slopeLabelText, padding + 5, padding + 5);
        }
    }

    function drawVmaxGraph() {
        const canvas = document.getElementById('vmaxGraphCanvas');
        if (!canvas || !canvas.getContext || !isVmaxMode) return;
        const ctx = canvas.getContext('2d');
        const padding = 40;
        const graphWidth = canvas.width - 2 * padding;
        const graphHeight = canvas.height - 2 * padding;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#f9fafb";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        let allExperimentsToPlot = [...experiments];
        if (currentExperiment && currentExperiment.variables && Object.keys(currentExperiment.variables).length > 0) {
             allExperimentsToPlot.push(currentExperiment);
        }
        if (allExperimentsToPlot.length === 0 || allExperimentsToPlot.every(exp => !exp.data || exp.data.length === 0)) return;
        let allData = allExperimentsToPlot.map(exp => exp.data || []).flat();
        if (allData.length === 0) return;
        let maxH2O2_Data = Math.max(10, ...allData.map(d => d.h2o2));
        let maxH2O2_Axis = maxH2O2_Data * 1.1;
        let maxRate = Math.max(1, ...allData.map(d => d.rate));
        allExperimentsToPlot.forEach(exp => { if (exp.fittedParams && exp.fittedParams.Vmax) { maxRate = Math.max(maxRate, exp.fittedParams.Vmax * 1.1); } });
        maxRate = Math.max(1, maxRate * 1.1);

        // Draw Axes (Y Ticks)
        ctx.strokeStyle = "#d1d5db"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(padding, padding); ctx.lineTo(padding, canvas.height - padding); ctx.stroke();
        ctx.textAlign = "right"; ctx.textBaseline = "middle";
        const numYTicks = 5;
        for (let i = 0; i <= numYTicks; i++) { let yVal = (maxRate / numYTicks) * i; let y = (canvas.height - padding) - (yVal / maxRate) * graphHeight; ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(padding - 5, y); ctx.stroke(); let yLabel = yVal < 1 ? yVal.toFixed(2) : yVal < 10 ? yVal.toFixed(1) : Math.round(yVal).toString(); ctx.fillStyle = "#6b7280"; ctx.font = "11px 'Inter', sans-serif"; ctx.fillText(yLabel, padding - 8, y); }
        // Draw Axes (Y Title - Adjusted Position)
        ctx.save();
        ctx.translate(5, canvas.height / 2); // << MODIFIED X TRANSLATION to 5
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = "center"; ctx.fillStyle = "#374151"; ctx.font = "bold 12px 'Inter', sans-serif";
        ctx.fillText("Mean Initial Rate (ppm/s)", 0, 0);
        ctx.restore();
        // Draw Axes (X)
        ctx.beginPath(); ctx.moveTo(padding, canvas.height - padding); ctx.lineTo(canvas.width - padding, canvas.height - padding); ctx.stroke();
        ctx.textAlign = "center"; ctx.textBaseline = "top";
        let xTickStep = 50; if (maxH2O2_Data <= 50) xTickStep = 10; else if (maxH2O2_Data <= 100) xTickStep = 20; else if (maxH2O2_Data <= 200) xTickStep = 40; else if (maxH2O2_Data <= 400) xTickStep = 50; else xTickStep = 100;
        for (let t = 0; t <= maxH2O2_Data + xTickStep; t += xTickStep) { let x = padding + (t / maxH2O2_Axis) * graphWidth; if(x > canvas.width - padding + 5) break; if (t >= 0){ ctx.beginPath(); ctx.moveTo(x, canvas.height - padding); ctx.lineTo(x, canvas.height - padding + 5); ctx.stroke(); } ctx.fillStyle = "#6b7280"; ctx.font = "11px 'Inter', sans-serif"; if (t === 0 || t % xTickStep === 0) { ctx.fillText(Math.round(t).toString(), x, canvas.height - padding + 8); } }
        ctx.fillStyle = "#374151"; ctx.font = "bold 12px 'Inter', sans-serif"; ctx.fillText("H₂O₂ Concentration (mM)", canvas.width / 2, canvas.height - padding + 25);

        // Plot Legend, Data Points, and Fit Lines
        let colors = ['#3b82f6', '#22c55e', '#f97316', '#ef4444', '#8b5cf6'];
        let lineStyles = [[], [5, 5], [10, 3, 3, 3], [2, 4], [8, 4, 2, 4]];
        const legendRightX = canvas.width - padding - 10; const legendY = padding + 10; const legendItemHeight = 15; const swatchWidth = 12; const textOffsetX = 5;
        ctx.font = "11px 'Inter', sans-serif"; ctx.textAlign = "right"; ctx.textBaseline = "top";
        allExperimentsToPlot.forEach((exp, idx) => { if (!exp || !exp.variables) return; let color = colors[idx % colors.length]; let currentY = legendY + idx * legendItemHeight; ctx.fillStyle = color; ctx.fillRect(legendRightX - swatchWidth, currentY, swatchWidth, legendItemHeight - 3); ctx.fillStyle = "#333"; ctx.fillText(`Experiment ${idx + 1}`, legendRightX - swatchWidth - textOffsetX, currentY); });
        allExperimentsToPlot.forEach((exp, idx) => { if (!exp || !exp.data) return; let color = colors[idx % colors.length]; let lineDash = lineStyles[idx % lineStyles.length]; ctx.fillStyle = color; exp.data.forEach(d => { let x = padding + (d.h2o2 / maxH2O2_Axis) * graphWidth; let y = canvas.height - padding - (d.rate / maxRate) * graphHeight; if(isFinite(x) && isFinite(y)){ ctx.beginPath(); ctx.arc(x, y, 4, 0, 2 * Math.PI); ctx.fill(); } }); if (exp.showFit && exp.fittedParams) { ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.setLineDash(lineDash); ctx.beginPath(); let steps = 100; let plotMaxH2O2 = maxH2O2_Data; for (let i = 0; i <= steps; i++) { let h2o2 = (i / steps) * plotMaxH2O2; let rate = exp.fittedParams.Vmax * h2o2 / (exp.fittedParams.Km + h2o2); let x = padding + (h2o2 / maxH2O2_Axis) * graphWidth; let clampedRate = Math.max(0, Math.min(rate, maxRate)); let y = canvas.height - padding - (clampedRate / maxRate) * graphHeight; if (isFinite(x) && isFinite(y)) { if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); } } ctx.stroke(); } });
        ctx.setLineDash([]);
    }
    function updateUI() { const instructions = document.getElementById('instructions'); const variablesChosenBtn = document.getElementById('variablesChosenBtn'); const addExperimentBtn = document.getElementById('addExperimentBtn'); const tableContainer = document.querySelector('.table-container'); const vmaxGraphContainer = document.querySelector('.vmax-graph-container'); const vmaxExperimentsContainer = document.querySelector('.vmax-experiments-container'); const substrateInput = document.getElementById('substrateInput'); const substrateBox = substrateInput.closest('.input-box'); const genBtn = document.getElementById('genBtn'); const resetBtn = document.getElementById('resetBtn'); const csvBtn = document.getElementById('csvBtn'); const variableSliders = ['enzymeInput', 'competitiveInput', 'noncompetitiveInput', 'tempInput', 'phInput']; document.querySelectorAll('.highlight-button-glow').forEach(el => el.classList.remove('highlight-button-glow')); document.querySelectorAll('.highlight-input-glow').forEach(el => el.classList.remove('highlight-input-glow')); if (isVmaxMode) { tableContainer.style.display = 'none'; vmaxGraphContainer.style.display = 'block'; vmaxExperimentsContainer.style.display = 'block'; if (isSettingVariables) { instructions.textContent = `Set fixed conditions for Experiment ${experiments.length + 1}`; variablesChosenBtn.style.display = 'inline-block'; variablesChosenBtn.disabled = false; variablesChosenBtn.classList.add('highlight-button-glow'); addExperimentBtn.style.display = 'none'; substrateInput.disabled = true; if(substrateBox) substrateBox.style.opacity = '0.6'; genBtn.disabled = true; resetBtn.disabled = false; csvBtn.disabled = false; variableSliders.forEach(id => { const slider = document.getElementById(id); if(slider) slider.disabled = false; const box = slider.closest('.input-box'); if(box) box.style.opacity = '1.0'; }); } else { instructions.textContent = `Set H₂O₂ concentration and Generate Results (repeat for multiple points)`; variablesChosenBtn.style.display = 'none'; addExperimentBtn.style.display = 'inline-block'; addExperimentBtn.disabled = false; substrateInput.disabled = false; if(substrateBox){ substrateBox.style.opacity = '1.0'; substrateBox.classList.add('highlight-input-glow'); } genBtn.disabled = false; resetBtn.disabled = false; csvBtn.disabled = false; variableSliders.forEach(id => { const slider = document.getElementById(id); if(slider) slider.disabled = true; const box = slider.closest('.input-box'); if(box) box.style.opacity = '0.6'; }); } } else { instructions.textContent = ""; variablesChosenBtn.style.display = 'none'; addExperimentBtn.style.display = 'none'; tableContainer.style.display = 'block'; vmaxGraphContainer.style.display = 'none'; vmaxExperimentsContainer.style.display = 'none'; substrateInput.disabled = false; if(substrateBox) substrateBox.style.opacity = '1.0'; genBtn.disabled = false; resetBtn.disabled = false; csvBtn.disabled = false; variableSliders.forEach(id => { const slider = document.getElementById(id); if(slider) slider.disabled = false; const box = slider.closest('.input-box'); if(box) box.style.opacity = '1.0'; }); } }

    function handleSliderKeyDown(event) {
        const key = event.key;
        if ((key === '+' || key === '=' || key === '-') && isHoveringInputBox && currentlyHoveredSlider && !currentlyHoveredSlider.disabled) {
            event.preventDefault();
            const slider = currentlyHoveredSlider;
            let stepChange = 0;
            if (key === '+' || key === '=') { stepChange = 1; }
            else if (key === '-') { stepChange = -1; }
            const step = parseFloat(slider.step) || 1;
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            let currentValue = parseFloat(slider.value);
            let newValue = currentValue + (stepChange * step);
            newValue = Math.max(min, Math.min(max, newValue));
            const stepString = String(step);
            const decimalPlaces = stepString.includes('.') ? stepString.split('.')[1].length : 0;
            if (decimalPlaces > 0) {
                newValue = parseFloat(newValue.toFixed(decimalPlaces));
            }
            slider.value = newValue;
            slider.dispatchEvent(new Event('input', { bubbles: true }));
        }
        else if (key === 'Enter') {
            const genBtn = document.getElementById('genBtn');
            if (genBtn && !genBtn.disabled) {
                event.preventDefault();
                console.log("Enter key pressed, triggering Generate Results...");
                generateResults();
            }
        }
    }

    window.addEventListener('load', () => {
        setupScene();
        updateCanvasSizes();
        updateUI();
        drawGraph();
        drawVmaxGraph();

        const inputBoxes = document.querySelectorAll('.input-box');
        inputBoxes.forEach(box => {
            const slider = box.querySelector('input[type="range"]');
            if (slider) {
                box.addEventListener('mouseenter', () => {
                    if (!slider.disabled) {
                        currentlyHoveredSlider = slider;
                        isHoveringInputBox = true;
                        box.classList.add('keyboard-active');
                    }
                });
                box.addEventListener('mouseleave', () => {
                    if (currentlyHoveredSlider === slider) {
                         currentlyHoveredSlider = null;
                         isHoveringInputBox = false;
                    }
                    box.classList.remove('keyboard-active');
                });
            }
        });
        document.addEventListener('keydown', handleSliderKeyDown);
    });
    window.addEventListener('resize', () => { updateCanvasSizes(); });

</script>
</body>
</html>
